# 3. Взвешенный случайный выбор галереи

**Приоритет:** Высокий (Core функциональность)

## Описание
Реализация взвешенного случайного выбора галереи на основе весов. Вероятность показа пропорциональна весу галереи.

## Требования из MVP
- Вероятность = вес_галереи / сумма_весов
- Взвешенный случайный выбор
- Исключенные галереи не участвуют в выборе

## Задачи

### 3.1. Метод получения весов активных галерей
**Файл:** `bot/database.py`

Добавить метод:
- `get_active_gallery_weights()` - получение словаря {gallery_id: weight} для всех неисключенных галерей
- Исключать галереи с `excluded = TRUE`

### 3.2. Алгоритм взвешенного случайного выбора
**Файл:** `bot/stash_client.py` или новый `bot/gallery_selector.py`

Создать функцию/метод:
- `select_gallery_by_weight(weights_dict)` - взвешенный случайный выбор
- Использовать алгоритм: 
  1. Вычислить сумму всех весов
  2. Сгенерировать случайное число от 0 до суммы
  3. Пройти по галереям, накапливая веса, пока не превысим случайное число

### 3.3. GraphQL запрос для получения изображений из конкретной галереи
**Файл:** `bot/stash_client.py`

Добавить метод:
- `get_random_image_from_gallery(gallery_id, exclude_ids)` - получение случайного изображения из конкретной галереи

GraphQL запрос:
```graphql
query GetRandomImageFromGallery($gallery_id: ID!, $per_page: Int!) {
  findImages(
    filter: {
      galleries: { value: [$gallery_id], modifier: INCLUDES }
      per_page: $per_page
      sort: "random"
    }
  ) {
    images {
      id
      title
      rating100
      paths { thumbnail preview image }
      galleries { id title }
      performers { id name }
    }
  }
}
```

### 3.4. Интеграция в выбор изображения с fallback
**Файл:** `bot/telegram_handler.py`

Модифицировать `_get_random_image()`:
- **КРИТИЧНО:** Добавить fallback-механизм для безопасного релиза
- Алгоритм:
  1. Проверить наличие `voting_manager` и весов
  2. Если есть веса и они не пустые:
     - Получить веса всех активных галерей
     - Выбрать галерею взвешенным случайным выбором
     - Получить случайное изображение из выбранной галереи
  3. Если весов нет или произошла ошибка:
     - **Fallback:** Использовать старый метод `get_random_image_with_retry()`
     - Логировать предупреждение, но не прерывать работу

### 3.5. Кэширование весов
**Файл:** `bot/voting.py` или новый модуль

Добавить базовое кэширование весов для оптимизации:
- Кэш весов галерей с TTL (например, 60 секунд)
- Инвалидация кэша при обновлении веса (после голосования)

**Примечание:** Детальная реализация кэширования описана в задаче 13.

## Тестирование
- Проверить корректность взвешенного выбора (галереи с большим весом выбираются чаще)
- Проверить исключение исключенных галерей
- Проверить fallback на старый метод
- Проверить производительность (кэширование)

## Зависимости
- Задача 1: Система весов галерей
- Задача 2: Статистика галереи (для получения списка галерей)

## Безопасность релиза

### ✅ Можно релизить после этой задачи

**Условия для безопасного релиза:**
1. **ОБЯЗАТЕЛЬНО:** Реализован fallback на старый метод выбора изображений
2. Если весов нет (новые галереи, ошибка БД), используется старый метод
3. Если взвешенный выбор не удался, автоматически переключается на старый метод
4. Все ошибки логируются, но не прерывают работу бота

**Fallback-механизмы:**
```python
# Псевдокод реализации
try:
    if voting_manager and has_weights():
        image = await get_weighted_selection()
    else:
        image = await get_old_method()  # Fallback
except Exception as e:
    logger.warning(f"Weighted selection failed: {e}, using fallback")
    image = await get_old_method()  # Fallback
```

**Проверка перед релизом:**
- [ ] Бот запускается без ошибок
- [ ] Команда `/random` работает
- [ ] Если весов нет, используется старый метод (проверить логи)
- [ ] Если взвешенный выбор не удался, используется fallback
- [ ] Выбор изображений работает в обоих случаях

**Что НЕ сломается:**
- Выбор изображений (есть fallback)
- Голосование (работает как раньше)
- Все остальные функции

## Связанные задачи
- Задача 4: Алгоритм выбора изображения в галерее
- Задача 13: Кэширование весов галерей (детальная реализация)
