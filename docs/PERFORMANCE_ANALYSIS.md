# Анализ производительности бота

## Добавленный инструментарий

### 1. Модуль профилирования (`bot/performance.py`)

Добавлены утилиты для измерения времени выполнения:

- **`timing_decorator`** - декоратор для автоматического измерения времени функций
- **`timing_context`** - контекстный менеджер для измерения блоков кода
- **`PerformanceTimer`** - класс для детального профилирования с несколькими этапами

### 2. Встроенное профилирование

Добавлено измерение времени для:

#### StashClient (`bot/stash_client.py`):
- `_execute_query()` - время выполнения GraphQL запросов
- `download_image()` - время и скорость скачивания изображений
- `get_random_image()` - общее время получения случайного изображения
- `get_random_image_weighted()` - время получения с фильтрацией

#### Database (`bot/database.py`):
- `get_recent_image_ids()` - время получения недавних ID
- `get_blacklisted_performers()` - время запроса blacklist перформеров
- `get_whitelisted_performers()` - время запроса whitelist перформеров
- `get_blacklisted_galleries()` - время запроса blacklist галерей
- `get_whitelisted_galleries()` - время запроса whitelist галерей

#### TelegramHandler (`bot/telegram_handler.py`):
- `_send_random_photo()` - полный процесс с детальными этапами:
  - Получение recent IDs из БД
  - Получение filtering lists
  - Получение случайного изображения
  - Скачивание изображения
  - Отправка в Telegram
  - Сохранение в БД

## Оптимизации

### 1. Кэширование фильтров (bot/voting.py)

Добавлен кэш для списков фильтрации с TTL 60 секунд:
- Уменьшает количество запросов к БД
- Инвалидируется после каждого голосования
- Логирует использование кэша

### 2. Оптимизация GraphQL запросов (bot/stash_client.py)

- Уменьшено количество запрашиваемых изображений: **50 → 20**
- Убраны теги из запроса (не критичны для выбора)
- Это уменьшает объем передаваемых данных и ускоряет запрос

## Как использовать логи для анализа

### Запуск бота

```bash
# Если бот в Docker
docker-compose logs -f bot

# Если бот запущен локально
tail -f bot.log
```

### Анализ логов

После выполнения команды `/random` вы увидите:

```
⏱️  DB get_recent_image_ids: 0.003s (15 items, 30 days)
⏱️  Refreshing filtering lists cache
⏱️  DB get_blacklisted_performers: 0.002s (3 items)
⏱️  DB get_blacklisted_galleries: 0.001s (1 items)
⏱️  DB get_whitelisted_performers: 0.002s (5 items)
⏱️  DB get_whitelisted_galleries: 0.001s (2 items)
⏱️  GraphQL query executed: 0.450s
⏱️  get_random_image: 0.453s (query: 0.450s)
⏱️  get_random_image_weighted: 0.455s (1 attempts)
⏱️  Image download: 0.120s (45.2 KB, 376.7 KB/s)
============================================================
⏱️  Performance Report: Send random photo
------------------------------------------------------------
  Get recent IDs from DB...................... 0.003s (  0.5%)
  Get filtering lists from DB................. 0.009s (  1.5%)
  Get random image (weighted)................. 0.455s ( 75.4%)
  Download image.............................. 0.120s ( 19.9%)
  Send to Telegram............................ 0.015s (  2.5%)
  Save to database............................ 0.002s (  0.3%)
------------------------------------------------------------
  TOTAL....................................... 0.604s (100.0%)
============================================================
```

### Интерпретация результатов

#### Если "Get random image (weighted)" > 70%:
**Проблема:** Медленный запрос к StashApp или множественные retry

**Решения:**
1. Проверить сетевое подключение к StashApp
2. Уменьшить количество фильтров (слишком строгие ограничения)
3. Увеличить размер коллекции в StashApp
4. Рассмотреть возможность индексации в StashApp

#### Если "Download image" > 40%:
**Проблема:** Медленная загрузка preview

**Решения:**
1. Проверить размер preview файлов в StashApp (Settings → Interface → Maximum image preview size)
2. Рассмотреть использование thumbnail вместо preview
3. Проверить пропускную способность сети
4. Проверить, что используется локальная сеть, а не через интернет

#### Если "Send to Telegram" > 30%:
**Проблема:** Медленная отправка в Telegram API

**Решения:**
1. Проверить интернет-соединение
2. Уменьшить размер изображения перед отправкой
3. Проверить ограничения Telegram API

#### Если "Get filtering lists from DB" > 10%:
**Проблема:** Медленные запросы к БД (маловероятно с SQLite)

**Решения:**
1. Проверить, что кэш работает (должен использоваться после первого запроса)
2. Проверить индексы в БД
3. Очистить старые записи из БД

## Целевые значения производительности

### Хорошая производительность:
- **Общее время:** < 3 секунды
- **GraphQL запрос:** < 0.5 секунды
- **Скачивание preview:** < 0.2 секунды
- **Отправка в Telegram:** < 0.5 секунды

### Приемлемая производительность:
- **Общее время:** 3-5 секунд
- **GraphQL запрос:** 0.5-1.0 секунды
- **Скачивание preview:** 0.2-0.5 секунды
- **Отправка в Telegram:** 0.5-1.0 секунды

### Требует оптимизации:
- **Общее время:** > 5 секунд
- **GraphQL запрос:** > 1.0 секунды
- **Скачивание preview:** > 0.5 секунды
- **Отправка в Telegram:** > 1.0 секунды

## Дополнительные оптимизации (если нужно)

### 1. Уменьшение размера preview в StashApp

В StashApp Settings → Interface:
- **Maximum image preview size:** 400px (вместо больших значений)

### 2. Использование thumbnail вместо preview

В `bot/stash_client.py`, изменить в `StashImage.__init__`:

```python
# Было:
self.image_url = paths.get('preview') or paths.get('image', '')

# Стало (для еще большей скорости):
self.image_url = paths.get('thumbnail') or paths.get('preview') or paths.get('image', '')
```

### 3. Параллельные запросы

Если есть несколько независимых операций, можно использовать `asyncio.gather()`:

```python
# Параллельное выполнение
recent_ids_task = asyncio.create_task(db.get_recent_image_ids(30))
filters_task = asyncio.create_task(voting_manager.get_filtering_lists())

recent_ids, filters = await asyncio.gather(recent_ids_task, filters_task)
```

### 4. Увеличение TTL кэша

Если фильтры меняются редко, можно увеличить TTL:

```python
# В bot/main.py при инициализации VotingManager:
voting_manager = VotingManager(
    database=database,
    stash_client=stash_client,
    cache_ttl=300  # 5 минут вместо 1 минуты
)
```

## Мониторинг в продакшене

Для долгосрочного мониторинга рекомендуется:

1. **Сбор метрик в БД** - сохранять время выполнения каждого запроса
2. **Prometheus metrics** - экспортировать метрики для Grafana
3. **Алерты** - уведомления при превышении пороговых значений
4. **Регулярный анализ** - еженедельный обзор трендов производительности

## Тестирование

Для проверки производительности:

1. Запустите бота
2. Выполните несколько команд `/random`
3. Проанализируйте логи
4. Сравните с целевыми значениями
5. Примените оптимизации если нужно
6. Повторите тест

## Заключение

С добавленным инструментарием вы можете:
- Видеть точное время каждого этапа
- Определять узкие места
- Отслеживать эффект оптимизаций
- Мониторить производительность в реальном времени

Все изменения обратно совместимы и не влияют на функциональность бота.
